\chapter{条件语句和递归}

\section{ 模操作符}

\index{modulus operator 模操作符}
\index{operator!modulus 操作符!模}

模操作符用于两个整数，第一个操作数除以第二个操作数产生余数。在Python
中，模操作符是一个百分号（\verb"%"）。语法的格式和其他的操作符相同。

\beforeverb
\begin{verbatim}
>>>quotient = 7 / 3
>>>print quotient
2
>>>remainder = 7 % 3
>>>print remainder
1
\end{verbatim}
\afterverb

7除以3等于2余1。\\

模操作符是非常有用的，比如，你可以查看一个数是否可以被另一个数整除---
如果{\tt x \% y}是0，{\tt x}就可以被{\tt y}整除。\\

\index{divisibility 整除}

你也可以用模运算来提取整数的最右边的数字。比如，{\tt x \% 10 }得到{\tt x}的最右面的一个数字\footnote{译注：个位数}（以十为底）。类似地，
{\tt x \% 100}得到最后的两位数字\footnote{十位和个位的数字}。

\section{布尔表达式}
\index{boolean expression 布尔表达式}
\index{expression!boolean}
\index{logical operator 逻辑运算符}
\index{operator!logical}

布尔表达式的结果要么是真(true），要么为假（false）。下面的例子是使用
{\tt ==}运算符，比较两个操作数，如果相等则结果为{\tt True},否则为{\tt False}:

\beforeverb
\begin{verbatim}
>>> 5 == 5
True
>>> 5 == 6
False
\end{verbatim}
\afterverb

{\tt True}和{\tt False}是两个特殊的值，属于{\tt bool}类型；他们不是
字符串：

\index{True special value True特殊值}
\index{False special value False特殊值}
\index{specail value!True}
\index{special value!False}
\index{bool type bool类型}
\index{type!bool}

\beforeverb
\begin{verbatim}
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
\end{verbatim}
\afterverb

{\tt ==}运算符是关系运算符中的一个，其他的还有:

\beforeverb
\begin{verbatim}
      x != y               # x is not equal to y
      x > y                # x is greater than y
      x < y                # x is less than y
      x >= y               # x is greater than or equal to y
      x <= y               # x is less than or equal to y
\end{verbatim}
\afterverb


尽管你可能很熟悉这些运算符，他们在Python中的表示方法和数学中的有很大
的不同。一个常见的错误是只使用一个{\tt =}号，而不是两个{\tt ==}号。
记住{\tt =}是赋值操作符，{\tt ==}是关系运算符。而且，Python中没有这样
的符号{\tt =<}或者{\tt =>}\footnote{在FP(functional programming中可能
会遇到这个符号}。

\index{relational operator 关系运算符}
\index{operator!relational}

\section{逻辑运算符}
\index{logical operator 逻辑运算符}
\index{operator!logical}

有三个逻辑运算符：{\tt and},{\tt or}和{\tt not}。这些操作符的意思和
在英语中的意思差不多。比如，{\tt x > 0 and x < 10}为真，仅当{\tt x}
大于0小于10\footnote{译注：在Python中，更pythonic的写法是 0 < x < 10
。  这样的符号对于c/c++背景的程序员来说，有点陌生，在c/c++等值的分别
是\&\&, || ,!}。

\index{and operator and运算符}
\index{or operator or运算符}
\index{not operator not运算符}
\index{operator!and}
\index{operator!or}
\index{operator!not}

如果{\tt n \% 2 == 0 or n \% 3 == 0}有一个条件语句为真，则表达式的值就为真，亦即n可以被2或3整除。\\

最后，{\tt not}运算符对一个布尔表达式取反，所以如果{\tt (
x > y)为假，则{\tt not (x > y)}为真，亦即，{\tt x}小于或等于{\tt y}。\\

严格来说，逻辑运算符的操作数只能是布尔表达式，但是Python
对此可没什么严格要求。任何不为0的整数也被解释成{\tt True}
\footnote{这个也可扩展到任何其他的类型，比如后面要涉及到的
list,tuple,dict,set还有str。}

\beforeverb
\begin{verbatim}
>>> 17 and True
True
\end{verbatim}
\afterverb

这个灵活性是很有用处的，但是可能会产生一些微妙的问题。我们
要尽可能的避免他们（除非知道自己在做什么）。

\section{条件执行}
\label{conditional execution}

\index{conditional statement 条件语句}
\index{statement!conditional}
\index{if statement if语句}
\index{statement!if}
\index{conditional execution 条件执行}

考虑到要写一些有用的程序，我们几乎总是需要检查条件，并改变相应的改变程序的行为。条件语句给了我们这个能力。最简单的要属{\tt if}语句了：



\beforeverb
\begin{verbatim}
if x > 0:
    print 'x is positive'
\end{verbatim}
\afterverb
{\tt if}语句后面的布尔表达式叫做条件。如果条件为真，则下面
缩进的语句就被执行。反之，则什么也不发生。\footnote{这是
针对本例而言，因为本例只有一条语句。在其他的情况下，可能
会有诸如{\tt else}之类的语句。}

\index{condition 条件}
\index{compound statment}
\index{statment!compound}

{\tt if}语句和函数定义有着相同的结构：
一个头，后面跟着一个缩进的语句块。这样的语句叫做复合语句。\\

虽然对复合语句里面可以含有的语句数量不限，但是必须至少有一
条\footnote{c/c++中没有这样的限制}。偶然地，可能在语句体里
暂时不需要语句(通常作为一个占位符)。在这种情况下，我们可以
使用{\tt pass}语句，它什么也不做。



\index{pass statement}
\index{statement!pass}

\beforeverb
\begin{verbatim}
if x < 0:
    pass          # need to handle negative values!
\end{verbatim}
\afterverb

\section{选择执行}
\label {alternative execution}

\index{alternative executive 选择执行}
\index{else keyword else关键字}
\index{keyword!else}

{\tt if}语句的第二种形式是选择执行，此时，有两种可能性，
条件决定了哪一个可能性被执行。语法是这样:

\beforeverb
\begin{verbatim}
if x%2 == 0:
    print 'x is even'
else:
    print 'x is odd'
\end{verbatim}
\afterverb

如果{\tt x}除以2的余数是0，我们可以判定{\tt x}是偶数，程序
就输出这个效果。如果条件为假，第二个语句就被执行。因为条件
必须为真或假，其中一个必定会被执行。选择项叫做分支，因为
它们是执行流的分支。

\index{branch 分支}


\section{链式条件}
\index{chained conditional 链式条件}
\index{conditional!chained}

有时，可能会有不止两种可能性，我们就需要更多的分支。一种方式是使用链式条件语句。

\beforeverb
\begin{verbatim}
if x < y:
    print 'x is less than y'
elif x > y:
    print 'x is greater than y'
else:
    print 'x and y are equal'
\end{verbatim}
\afterverb

{\tt elif}是"else if"的缩写形式。再次说明一下，只有一条
语句被执行。{\tt elif}语句的数目也是没有限制的。如果要写
{\tt else}语句，必须是在链式条件的最后，但是如果没有，也是
允许的。

\index{elif keyword elif关键字}
\index{keyword!elif}

\beforeverb
\begin{verbatim}
if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
\end{verbatim}
\afterverb

每个条件按顺序被检查。如果第一个为假，下一个就被检查，如此
如此。如果有一个为真，相应的分支就被执行，链式语句也就终止
。尽管可能有多个条件为真，也只有第一个为真的分支被执行。\\

