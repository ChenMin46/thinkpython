\chapter{条件语句和递归}

\section{ 模操作符}

\index{modulus operator 模操作符}
\index{operator!modulus 操作符!模}

模操作符用于两个整数，第一个操作数除以第二个操作数产生余数。在Python
中，模操作符是一个百分号（\verb"%"）。语法的格式和其他的操作符相同。

\beforeverb
\begin{verbatim}
>>>quotient = 7 / 3
>>>print quotient
2
>>>remainder = 7 % 3
>>>print remainder
1
\end{verbatim}
\afterverb

7除以3等于2余1。\\

模操作符是非常有用的，比如，你可以查看一个数是否可以被另一个数整除---
如果{\tt x \% y}是0，{\tt x}就可以被{\tt y}整除。\\

\index{divisibility 整除}

你也可以用模运算来提取整数的最右边的数字。比如，{\tt x \% 10 }得到{\tt x}的最右面的一个数字\footnote{译注：个位数}（以十为底）。类似地，
{\tt x \% 100}得到最后的两位数字\footnote{十位和个位的数字}。

\section{布尔表达式}
\index{boolean expression 布尔表达式}
\index{expression!boolean}
\index{logical operator 逻辑运算符}
\index{operator!logical}

布尔表达式的结果要么是真(true），要么为假（false）。下面的例子是使用
{\tt ==}运算符，比较两个操作数，如果相等则结果为{\tt True},否则为{\tt False}:

\beforeverb
\begin{verbatim}
>>> 5 == 5
True
>>> 5 == 6
False
\end{verbatim}
\afterverb

{\tt True}和{\tt False}是两个特殊的值，属于{\tt bool}类型；他们不是
字符串：

\index{True special value True特殊值}
\index{False special value False特殊值}
\index{specail value!True}
\index{special value!False}
\index{bool type bool类型}
\index{type!bool}

\beforeverb
\begin{verbatim}
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
\end{verbatim}
\afterverb

{\tt ==}运算符是关系运算符中的一个，其他的还有:

\beforeverb
\begin{verbatim}
      x != y               # x is not equal to y
      x > y                # x is greater than y
      x < y                # x is less than y
      x >= y               # x is greater than or equal to y
      x <= y               # x is less than or equal to y
\end{verbatim}
\afterverb


尽管你可能很熟悉这些运算符，他们在Python中的表示方法和数学中的有很大
的不同。一个常见的错误是只使用一个{\tt =}号，而不是两个{\tt ==}号。
记住{\tt =}是赋值操作符，{\tt ==}是关系运算符。而且，Python中没有这样
的符号{\tt =<}或者{\tt =>}\footnote{在FP(functional programming中可能
会遇到这个符号}。

\index{relational operator 关系运算符}
\index{operator!relational}

\section{逻辑运算符}
\index{logical operator 逻辑运算符}
\index{operator!logical}

有三个逻辑运算符：{\tt and},{\tt or}和{\tt not}。这些操作符的意思和
在英语中的意思差不多。比如，{\tt x > 0 and x < 10}为真，仅当{\tt x}
大于0小于10\footnote{译注：在Python中，更pythonic的写法是 0 < x < 10
。  这样的符号对于c/c++背景的程序员来说，有点陌生，在c/c++等值的分别
是\&\&, || ,!}。

\index{and operator and运算符}
\index{or operator or运算符}
\index{not operator not运算符}
\index{operator!and}
\index{operator!or}
\index{operator!not}

如果{\tt n \% 2 == 0 or n \% 3 == 0}有一个条件语句为真，则表达式的值就为真，亦即n可以被2或3整除。\\

最后，{\tt not}运算符对一个布尔表达式取反，所以如果{\tt (
x > y)为假，则{\tt not (x > y)}为真，亦即，{\tt x}小于或等于{\tt y}。\\

严格来说，逻辑运算符的操作数只能是布尔表达式，但是Python
对此可没什么严格要求。任何不为0的整数也被解释成{\tt True}
\footnote{这个也可扩展到任何其他的类型，比如后面要涉及到的
list,tuple,dict,set还有str。}

\beforeverb
\begin{verbatim}
>>> 17 and True
True
\end{verbatim}
\afterverb

这个灵活性是很有用处的，但是可能会产生一些微妙的问题。我们
要尽可能的避免他们（除非知道自己在做什么）。

\section{条件执行}
\label{conditional execution}

\index{conditional statement 条件语句}
\index{statement!conditional}
\index{if statement if语句}
\index{statement!if}
\index{conditional execution 条件执行}

考虑到要写一些有用的程序，我们几乎总是需要检查条件，并改变相应的改变程序的行为。条件语句给了我们这个能力。最简单的要属{\tt if}语句了：



\beforeverb
\begin{verbatim}
if x > 0:
    print 'x is positive'
\end{verbatim}
\afterverb
{\tt if}语句后面的布尔表达式叫做条件。如果条件为真，则下面
缩进的语句就被执行。反之，则什么也不发生。\footnote{这是
针对本例而言，因为本例只有一条语句。在其他的情况下，可能
会有诸如{\tt else}之类的语句。}

\index{condition 条件}
\index{compound statment}
\index{statment!compound}

{\tt if}语句和函数定义有着相同的结构：
一个头，后面跟着一个缩进的语句块。这样的语句叫做复合语句。\\

虽然对复合语句里面可以含有的语句数量不限，但是必须至少有一
条\footnote{c/c++中没有这样的限制}。偶然地，可能在语句体里
暂时不需要语句(通常作为一个占位符)。在这种情况下，我们可以
使用{\tt pass}语句，它什么也不做。



\index{pass statement}
\index{statement!pass}

\beforeverb
\begin{verbatim}
if x < 0:
    pass          # need to handle negative values!
\end{verbatim}
\afterverb

\section{选择执行}
\label {alternative execution}

\index{alternative executive 选择执行}
\index{else keyword else关键字}
\index{keyword!else}

{\tt if}语句的第二种形式是选择执行，此时，有两种可能性，
条件决定了哪一个可能性被执行。语法是这样:

\beforeverb
\begin{verbatim}
if x%2 == 0:
    print 'x is even'
else:
    print 'x is odd'
\end{verbatim}
\afterverb

如果{\tt x}除以2的余数是0，我们可以判定{\tt x}是偶数，程序
就输出这个效果。如果条件为假，第二个语句就被执行。因为条件
必须为真或假，其中一个必定会被执行。选择项叫做分支，因为
它们是执行流的分支。

\index{branch 分支}


\section{链式条件}
\index{chained conditional 链式条件}
\index{conditional!chained}

有时，可能会有不止两种可能性，我们就需要更多的分支。一种方式是使用链式条件语句。

\beforeverb
\begin{verbatim}
if x < y:
    print 'x is less than y'
elif x > y:
    print 'x is greater than y'
else:
    print 'x and y are equal'
\end{verbatim}
\afterverb

{\tt elif}是"else if"的缩写形式。再次说明一下，只有一条
语句被执行。{\tt elif}语句的数目也是没有限制的。如果要写
{\tt else}语句，必须是在链式条件的最后，但是如果没有，也是
允许的。

\index{elif keyword elif关键字}
\index{keyword!elif}

\beforeverb
\begin{verbatim}
if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
\end{verbatim}
\afterverb

每个条件按顺序被检查。如果第一个为假，下一个就被检查，如此
如此。如果有一个为真，相应的分支就被执行，链式语句也就终止
。尽管可能有多个条件为真，也只有第一个为真的分支被执行。\\


\section{嵌套的条件语句}
\index{nested conditional 嵌套的条件语句}
\index{conditional!nested}

一条条件语句也可以嵌套在另一个语句之中。我们写一个典型的例子：

\beforeverb
\begin{verbatim}
if x == y:
    print 'x and y are equal'
else:
    if x < y:
        print 'x is less than y'
    else:
        print 'x is greater than y'
\end{verbatim}
\afterverb
外层的条件包两个分支。第一个分支包含一个简单语句。第二个分支包含例外一个
{\tt if}语句，同时，这个{\tt if}语句也有两个分支。这两个简单的分之都是简
单语句，尽管他们本也可能是条件语句。\\

尽管缩进使得代码结构清晰，嵌套语句还是难以快速的理解。一般来说，尽可能的
避免使用嵌套条件语句。\\

逻辑运算符可以简化嵌套条件语句。比如，下面的代码可以只用一条条件语句：

\beforeverb
\begin{verbatim}
if 0 < x:
    if x < 10:
        print 'x is a positive single-digit number.'
\end{verbatim}
\afterverb

只有当我们“通过”了两个条件时，{\tt print}语句才会被执行，所以，我们可以用{\tt and}运算符达到同样的效果。

\beforeverb
\begin{verbatim}
if 0 < x and x < 10:
    print 'x is a positive single-digit number.'
\end{verbatim}
\afterverb
 


\section{递归}
\label{recusion}
\index{recursion 递归}


函数调用\footnote{译注：台湾的书籍一般翻译为呼叫，这个很形象}另外一个函数是合法的;函数调用他自身也是合法的。很难一眼看出这样做有什么好处\footnote{译者注：我猜，这种情况就像是自己把自己提起来一样～～}，但实践证明，
这是程序能做的最具有魔力的事情之一。比如，看下面的函数：

\beforeverb
\begin{verbatim}
def countdown(n):
    if n <= 0:
        print 'Blastoff!'
    else:
        print n
        countdown(n-1)
\end{verbatim}
\afterverb

如果{\tt n}是非正数，程序输出，“Blastoff!“，否则，输出{\tt n},然后调用
{\tt countdown}函数---也就是它自己---同时把{\tt n-1}当作参数传递给它。

如果我们调用这个函数，究竟发生了什么？

\beforeverb
\begin{verbatim}
>>> countdown(3)
\end{verbatim}
\afterverb
%
{\tt countdown}从{\tt n=3}开始执行，{\tt n}此时大于0，于是输出3，接着
调用自身。。。。。。

\begin{quote}
{\tt countdown}从{\tt n=2}开始执行，{\tt n}此时大于0，于是输出2，接着调用自身。。。。。。

\begin{quote}
{\tt countdown}从{\tt n=1}开始执行，{\tt n}此时大于0，于是输出1，接着调用自身。。。。。。

\begin{quote}
{\tt countdown}从{\tt n=0}开始执行，{\tt n}此时不大于0，输出“Blastoff!"
然后返回。
\end{quote}

接受{\tt n=1}的{\tt countdown}返回。
\edn{quote}

接受{\tt n=2}的{\tt countdown}返回。
\end{quote}

接受{\tt n=2}的{\tt countdown}返回。
\end{quote}

{\tt countdown}接受{\tt n=3}的函数返回。

然后，我们就会到\verb"__main__"里了。整个输出如下：

\beforeverb
\begin{verbatim}
3
2
1
Blastoff!
\end{verbatim}
\afterverb

 调用自身的函数称作递归函数；调用的过程叫做递归。

 \index{recursion 递归}
 \index{function!recursive}

另外一个例子，我们写一个打印一个字符串{\tt n}次的函数。

\beforeverb
\begin{verbatim}
def print_n(s, n):
    if n <= 0:
        return
    print s
    print_n(s, n-1)
\end{verbatim}
\afterverb

如果{\tt n <= 0}，{\tt return}语句退出函数。执行流立刻返回到调用者，
剩余的部分就不再被执行了。

\index{return statement return语句}
\index{statement!return}

函数的剩余部分和{\tt countdown}还书相似：如果{\tt n}大于0，输出{\tt s},然后调用自身显示{\tt s} $n-1$次。所以，输出的行数是{\tt 1 ＋ (n-1)}，
也就是{\tt n}次。\\

这样简单的例子，其实可以很容易用一个{\tt for}循环来实现。但我们以后将会看
到很难写成{\tt for}循环形式，但是很容易用递归实现的例子，我们现在就
开始认识递归是有好处的。

{\section{递归函数的堆栈图}
\index{stack diagram 堆栈图}
\index{function frame 函数图}
\index{frame 图}



